import itertools
# Функциональное программирование.
# Основывается на функциях. Функции высшего порядка принимают другие функции в качестве аргументов.
def apply_twice(func, arg):  # Эта функция принимает другую функцию и вызывает ее дважды внутри своего тела
    return func(func(arg))

def add_five(x):
    return x + 5

print(apply_twice(add_five, 10))

# Чистые функции не имеют побочных эффектов и возвращают значение, зависящее только от своих аргументов.
# Например cos(x) будет всегда возвращать одинаковый результат при одинаковом значении х
def pure_function(x, y):
    temp = x + 2*y
    return temp / (2*x + y)

# Нечистая функция:
some_list = []

def impure(arg):   # Эта функция не является чистой, потому что изменила состояние some_list
    some_list.append(arg)

# Анонимные лямбда-функции
def my_func(f, arg):
    return f(arg)

my_func(lambda x: 2*x*x, 5)

# named function:
def polynomial(x):
    return x**2 + 5*x + 4
print(polynomial(-4))

# the same lambda function:
print((lambda x: x**2 + 5*x + 4)(-4))

# Лямбда-функциям можно присваивать переменные и использовать их как обычные функции. Но чаще для этого используют def
double = lambda x: x * 2
print(double(7))

# Функции map и filter полезны для работы с итерируемыми объектами, как списки.
# map принимает функцию и объект как аргументы и возвращает новый итерируемый объект, а функция применяется к каждому аргументу
def add_five(x):
    return x + 5

nums = [11, 22, 33, 44, 55]
result = list(map(add_five, nums))  # Функция list нужна, чтобы преобразовать результат в список
print(result)

# Тот же результат с функцией lambda:
nums = [11, 22, 33, 44, 55]

result = list(map(lambda x: x+5, nums))
print(result)

# Функция filter предназначена для фильтрования итерируемого объекта путем удаления элементов, которые не соответствуют
#   предикату (функции, которая возвращает логическую переменную)
nums = [11, 22, 33, 44, 55]
res = list(filter(lambda x: x % 2 == 0, nums))  # Для вывода результата он должен быть вручную преобразован в список
print(res)

nums1 = [1, 2, 5, 4, 8, 3, 0, 7]
res1 = list(filter(lambda x: x < 5, nums1))
print(res1)


# Генераторы. Итерируемый тип, которому не присвоить произвольные индексы. Создаются при помощи инструкции yield
def countdown():
    i = 5
    while i > 0:
        yield i  # Инструкция yield определяет генератор, заменяет значение, возвращаемое функцией и возвращает результат
        i -= 1

for i in countdown():
    print(i)

# Генераторы не ограничены в памяти и могут выполняться бесконечно. Они позволяют объявить функцию, которая может быть
# использована в цикле подобно итератору

# def infinite_sevens():
#     while True:
#         yield 7
#
# for i in infinite_sevens():
#     print(i)

# Генератор простых чисел. (Допустим функцию is_prime мы уже определили):

# def get_primes():
#     num = 2
#     while True:
#         if is_prime(num):
#             yield num
#         num += 1

# Конечные генераторы могут быть преобразованы в списки
def numbers(x):
    for i in range(x):
        if i % 2 == 0:
            yield i

print(list(numbers(11)))

def make_word():
    word = ''
    for ch in "spam":
        word += ch
        yield word

print(list(make_word()))

# Декораторы
# Предназначены для модификации функций с помощью других функций. Можно изменить поведение функции, не меняя ее саму
def decor(func):
    def wrap():
        print("============")
        func()
        print('============')
    return wrap

def print_text():
    print("Hello world!")

decorated = decor(print_text)
decorated()

# Мы определили функцию decor у которой единственный параметр func. Внутри мы определили вложенную функцию wrap
# wrap выдает строку, затем вызовет func и затем ещё строку.
# Можно сказать, что переменная decorated - декорированная версия print_text, т.е. print_text + что-то ещё.
# Если мы хотим полностью заменит print_text на декорированную версию, можно повторно присвоить переменную:
print_text = decor(print_text)
print_text()  # Теперь print_text привязана к декорированной версии

# Кроме переменной, обернуть функцию в декоратор можно поставив перед определением функции @ и имя декоратора.
# Функция может иметь несколько декораторов.
@decor
def print_text():
    print("Hello world!")

# Рекурсия.
# Центральное понятие самореференция, когда функция вызывает сама себя
# Факториал находит произведение всех положительных чисел до этого числа. Например, 5! (факториал 5) = 5*4*3*2*1(120)
def factorial(x):
    if x == 1:  # Базовый случай действует как команда выхода из рекурсии. Если его нет - функция будет бесконечной
        return 1
    else:
        return x * factorial(x-1)
print(factorial(5))

# Неправильная рекурсивная функция подобная циклу while(когда кончается память - аварийно завершается(RuntimeError)):

# def factorial(x):
#     return x * factorial(x-1)
#
# print(factorial(5))

# Косвенная рекурсия - когда функция вызывает другую функцию, которая вызывает первую. Так с любым кол-вом функций
def is_even(x):
    if x == 0:
        return True
    else:
        return is_odd(x-1)

def is_odd(x):
    return not is_even(x)

print(is_odd(17))
print(is_even(23))

def fib(x):
    if x == 0 or x == 1:
        return 1
    else:
        return fib(x-1) + fib(x-2)
print(fib(4))


# Множества. Создаются с помощью фигурных скобок или функции set
# Чтобы создать пустое множество, используем set(), так как {} используются для создания пустого словаря
num_set = {1, 2, 3, 4, 5}
word_set = set(["spam", "eggs", "sausage"])

print(3 in num_set)
print("spam" not in word_set)

# Несмотря на отличия со списками, множества используют некоторые списковые операции, например len
# Множества неупорядоченны - индекса быть не может. Нельзя, чтобы они содержали дубликаты.
# Вместо append для добавления элемента - add.
# remove удаляет определенный элемент из множества
# pop удаляет произвольный элемент
nums = {1, 2, 1, 3, 1, 4, 5, 6}
print(nums)
nums.add(-7)
nums.remove(1)  # Удалит все числа "1"
print(nums)

# Арифметические операции над множествами
first = {1, 2, 3, 4, 5, 6}
second = {4, 5, 6, 7, 8, 9}
print(first | second)  # Объединяет два множества в одно
print(first & second)  # Пересечение. Возвращает элементы, находящиеся в обоих множествах
print(first - second)  # Разность. Возвращает элементы, которые есть только в первом множетве
print(second - first)
print(first ^ second)  # Симметричная разность. Возвращает все элементы, кроме тех, что есть у обоих множеств


# Структура данных.
# Когда использовать словарь:
# - когда требуется установить логическую связь пары ключ:значение
# - когда нужно провести быстрый поиск по данным используя ключ
# - когда данные нужно часто изменять
# Когда использовать списки:
# - Когда есть база данных, к которой не нужен произвольный доступ.
# - Когда нужна простая, итерируемая и часто модифицируемая коллекция данных
# Когда использовать множества:
# - Когда нужны уникальные элементы
# Когда использовать кортежи:
# - Когда данные не будут изменяться
# Часто кортеж используется в сочетании со словарем. Например кортеж может быть ключем, так как он неизменен

# Модуль itertools
# Стандартная библиотека, которая содержит полезные функции, например бесконечные итераторы.
# count создает бесконечную прогрессию вверх от заданного числа.
# cycle бесконечное число раз перебирает итерируемый объект(например, список или строку)
# repeat повторяет объект бесконечное или заданное количество раз
# takewhile - возвращает элементы из итерируемого объекта, удовлетворяющие предикативной функции
# chain - объединяет несколько итерируемых объектов в один
# accumulate - возвращает сумму значений внутри итерируемого объекта

for i in itertools.count(3):
    print(i)
    if i >= 11:
        break

nums = list(itertools.accumulate(range(8)))
print(nums)
print(list(itertools.takewhile(lambda x: x <= 6, nums)))

nums = [2, 4, 6, 7, 9, 8]
a = itertools.takewhile(lambda x: x % 2 == 0, nums)
print(list(a))

# В моделуле itertools есть и комбинатоные функции - используются когда нужно выполнить задачу со всеми возможными
# комбинациями некоторых элементов. Например, функции product и permutation

letters = ("A", "B", "C")
print(list(itertools.product(letters, range(2))))
print(list(itertools.permutations(letters)))

a1 = {1, 2}
print(len(list(itertools.product(range(3), a1))))

def power(x, y):
    if y == 0:
        return 1
    else:
        return x * power(x, y-1)

print(power(2, 3))

nums2 = [1, 2, 8, 3, 7]
res2 = list(filter(lambda x: x%2 == 0, nums2))
print(res2)